### DEFINE PYTORCH NEURAL NETWORK MODEL CLASS ##
import torch
import torch.nn as nn
import numpy as np
import pandas as pd

class NN_model(nn.Module):
    """Define Pytorch neural network model"""
    def __init__(self, input_size, hidden_size, n_layers, lr, dropout_prob, output_size=1):
        """
        Define model layers and hyperparameters
        Params:
        input_size   : int, number of features in the input 
        hidden_size  : int, size of hidden state / number of neurons per layer
        output_size  : int, number of features in the output
        n_layers     : int, number of layers
        lr           : float, learning rate for optimization algorithm
        dropout_prob : float, dropout probability for dropout regularization
        """
        super(NN_model, self).__init__()

        self.input_size = input_size
        self.output_size = output_size

        # Hyperparameters
        self.hidden_size = hidden_size
        self.n_layers = n_layers
        self.lr = lr
        self.dropout_prob = dropout_prob

        # Define the model layers
        self.layers = nn.ModuleList() # Create an empty ModuleList
        self.layers.append(nn.Linear(input_size, hidden_size)) # Add the first layer
        self.layers.append(nn.ReLU()) # Apply ReLU activation
        self.layers.append(nn.Dropout(p=dropout_prob)) # Add the first dropout layer following the first layer

        # Add the other hidden layers
        for k in range(n_layers - 1):
            self.layers.append(nn.Linear(hidden_size, hidden_size)) # add linear layer
            self.layers.append(nn.ReLU()) # add ReLU activation
            self.layers.append(nn.Dropout(p=dropout_prob)) # add dropout layer

        # Add the output layer
        self.layers.append(nn.Linear(hidden_size, output_size))

        return
    
    def forward(self, x):
        """
        Define the forward pass
        Params:
        x   : input tensor of shape (batch_size, input_size)
        out : output tensor of shape (batch_size, output_size)
        """

        # Loop over the layers in ModuleList
        for i, layer in enumerate(self.layers):
            x = layer(x) # Apply each layer to x
        
        # Apply the sigmoid to obtain the output probability
        out = nn.Sigmoid()(x)

        return out
